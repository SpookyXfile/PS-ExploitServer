package com.spookyx.xploitserver5;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Environment;
import android.util.Log;
import androidx.preference.PreferenceManager;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.net.ConnectException;
import java.net.Socket;
import java.util.Timer;
import java.util.TimerTask;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import fi.iki.elonen.NanoHTTPD;


public class ServerPayload extends NanoHTTPD
{

    private Context     wContext;

    private Timer       timer;
    private TimerTask   timerTask;

    private Utils       utils;

    private boolean     isWaiting;
    private int         portPayload;


    ServerPayload( Context context, int SvrPort )
    {
        super( SvrPort );

        this.wContext = context;

        isWaiting = false;

        utils   = new Utils();

        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences( context );

        //String  ipPayload   = preferences.getString("defaultIPPayload","192.168.1.2" );
        portPayload = Integer.valueOf( preferences.getString("defaultPortPayload","9020" ) );

        Log.i( "zoobi", "defaultPortPayload = " + portPayload );

    }

    @Override
    public Response serve( IHTTPSession session )
    {
        Map<String, String> headers = session.getHeaders();
        Map<String, String> files   = new HashMap<>();

        Method method = session.getMethod();

        String uri = session.getUri();

        //showToast("Start Payload Server", Toasty.Info );
        Log.i("zobbi", "serve" );

        if ( Method.POST.equals( method ) || Method.PUT.equals( method ) )
        {
            try
            {
                session.parseBody( files );
            }
            catch ( IOException ioEx )
            {

                return getResponse( "Error: " + ioEx.getMessage() );
            }
            catch ( ResponseException e )
            {

                return NanoHTTPD.newFixedLengthResponse( e.getStatus(), MIME_PLAINTEXT, e.getMessage() );
            }

        }

        // replace user guide path just in case
        if ( uri.contains( "/document/" ) )
        {
            String[] uriSpl = uri.split("/" );
            uri = "/" + uriSpl[ uriSpl.length - 1 ];

        }

        if ( uri.equals( "/" ) || uri.isEmpty() )
        {
            uri = "/index.html";

        }

        uri = uri.trim().replace( File.separatorChar,'/' );
        if ( uri.indexOf( '?' ) >= 0 )
        {
            uri = uri.substring( 0, uri.indexOf( '?' ) );

        }

        //File f = new File(Utils.getDataDir( wContext ) + uri );
        String pathName = Environment.getExternalStorageDirectory() + wContext.getString( R.string.payload_folder ) + uri;
        Log.i( "zobbi", "BIN pathname : " + pathName );

        String defaultPayloadFolder = Environment.getExternalStorageDirectory()
                                        + wContext.getString( R.string.payload_folder )
                                        + File.separator + "ps4-hen-vtx.bin";

        File f = new File( pathName );

        if ( uri.toLowerCase().contains( f.getName().toLowerCase() ) )
        {
            if ( f.getName().toLowerCase().equals( "index.html" ) )
            {
                if ( utils.GetSetting( wContext,"PAYLOAD", defaultPayloadFolder ).toLowerCase().endsWith( ".html" ) )
                {
                    File fh = new File( utils.GetSetting( wContext,"PAYLOAD", defaultPayloadFolder ) );

                    //Toasty.showToast( wContext,"Sending payload with server...", Toasty.Success );
                    Log.i("zobbi", "Payload sent" );

                    return serveFile( f.getName(), headers, fh );

                }

                isWaiting = false;

                stopTimerTask();

                String remoteIP = session.getRemoteIpAddress();

                Log.i( "zobbi", "remoteIP : " + remoteIP );

                isWaiting = true;

                startTimer();

                utils.SaveSetting( wContext,"REMHOST", remoteIP );

                Log.i("zobbi","Sending payload\nIP : " + remoteIP );

                String defaultPayloadFile = utils.GetSetting( wContext,"PAYLOAD", defaultPayloadFolder );

                sendPayload( defaultPayloadFile, remoteIP, portPayload );

            }

            return serveFile( f.getName(), headers, f );
        }
        else
        {
            return NanoHTTPD.newFixedLengthResponse( Response.Status.NOT_FOUND, MIME_PLAINTEXT,
                                                    "Error 404: File not found" );

        }
    }

    private Response serveFile( String uri, Map<String, String> header, File file )
    {
        Response res;

        String mime = getMimeTypeForFile( uri );

        try
        {
            String eTag = Integer.toHexString( ( file.getPath() + file.lastModified() + "" + file.length() ).hashCode() );

            long startFrom  = 0;
            long endAt      = -1;

            String range = header.get( "range" );
            if ( range != null )
            {
                if ( range.startsWith( "bytes=" ) )
                {
                    range = range.substring( "bytes=".length() );

                    int minus = range.indexOf('-');
                    try
                    {
                        if ( minus > 0 )
                        {
                            startFrom   = Long.parseLong( range.substring( 0, minus ) );
                            endAt       = Long.parseLong( range.substring( minus + 1 ) );
                        }
                    }
                    catch ( NumberFormatException ignored )
                    {

                    }

                }

            }

            long fileLen = file.length();
            if ( range != null && startFrom >= 0 )
            {
                if ( startFrom >= fileLen )
                {
                    res = createResponse( Response.Status.RANGE_NOT_SATISFIABLE, MIME_PLAINTEXT,"" );
                    res.addHeader("Content-Range","bytes 0-0/" + fileLen );
                    res.addHeader("ETag", eTag );

                }
                else
                    {
                        if ( endAt < 0 )
                            endAt = fileLen - 1;

                        long newLen = endAt - startFrom + 1;
                        if ( newLen < 0 )
                            newLen = 0;

                        final long dataLen = newLen;

                        FileInputStream fis = new FileInputStream( file )
                        {
                            @Override
                            public int available()
                            {
                                return (int) dataLen;
                            }

                        };

                        final long skip = fis.skip( startFrom );
                        Log.i( "zobbi","FileInputStream skip result : " + skip );

                        res = createResponse( Response.Status.PARTIAL_CONTENT, mime, fis );
                        res.addHeader("Content-Length", "" + dataLen);
                        res.addHeader("Content-Range", "bytes " + startFrom + "-" + endAt + "/" + fileLen );
                        res.addHeader("ETag", eTag );

                    }
            }
            else
                {
                    if ( eTag.equals( header.get( "if-none-match" ) ) )
                        res = createResponse(Response.Status.NOT_MODIFIED, mime,"" );
                    else
                        {
                            res = createResponse( Response.Status.OK, mime, new FileInputStream( file ) );
                            res.addHeader("Content-Length", "" + fileLen );
                            res.addHeader("ETag", eTag );
                        }
                }
        }
        catch ( IOException ioe )
        {
            res = getResponse( "Forbidden: Reading file failed" );
        }

        return ( res == null ) ? getResponse( "Error 404: File not found" ) : res;
    }

    private void sendPayload( final String filePath, final String host, final int port )
    {
        Log.i( "zobbi", "sendPayload : " + filePath );

        new Thread( new Runnable()
        {
            public void run()
            {
                while( isWaiting )
                {
                    try
                    {
                        File f = new File( filePath );
                        Socket socket = new Socket( host, port );

                        isWaiting = false;
                        stopTimerTask();

                        if( f.exists() )
                        {
                            BufferedOutputStream    outStream   = new BufferedOutputStream( socket.getOutputStream() );
                            BufferedInputStream     inStream    = new BufferedInputStream( new FileInputStream( f ) );

                            byte[] buffer = new byte[1024];

                            for ( int read = inStream.read(buffer); read >= 0; read = inStream.read(buffer) )
                            {
                                outStream.write( buffer,0, read );
                            }

                            inStream.close();
                            outStream.close();
                            socket.close();

                            //showToast("Payload sent", Toasty.Normal );
                            Log.i("zobbi","Payload sent" );

                        }
                        else
                        {
                            socket.close();

                            //showToast("Error: Payload missing\nSelect a payload to send first", Toasty.Error );
                            //misc.ShowToast( wContext,"Error: Payload missing\nSelect a payload to send first",
                            //                  misc.CENTER,0,0 );
                            Log.i("zobbi","Error: Payload missing\nSelect a payload to send first" );

                        }

                    }
                    catch( ConnectException e )
                    {
                        try
                        {
                            Thread.sleep(1000 );
                        }
                        catch( InterruptedException ignored )
                        {

                        }

                    }
                    catch ( IOException ignored )
                    {

                    }
                }
            }
        } ).start();

    }

    private Response createResponse( Response.Status status, String mimeType, InputStream message )
    {
        Response res = NanoHTTPD.newChunkedResponse( status, mimeType, message );
        res.addHeader("Accept-Ranges", "bytes" );

        return res;
    }

    private Response createResponse( Response.Status status, String mimeType, String message )
    {
        Response res = NanoHTTPD.newFixedLengthResponse( status, mimeType, message );
        res.addHeader("Accept-Ranges", "bytes" );

        return res;
    }

    private Response getResponse( String message )
    {

        return createResponse( Response.Status.OK,"text/plain", message );
    }

    private void startTimer()
    {
        timer = new Timer();

        initializeTimerTask();
        timer.schedule( timerTask,15000,30000 );

    }

    private void initializeTimerTask()
    {
        timerTask = new TimerTask()
        {
            public void run()
            {
                stopTimerTask();

                isWaiting = false;

                //showToast("Failed to send payload", Toasty.Warning );
                //misc.ShowToast( wContext,"Failed to send payload", misc.CENTER,0,0 );
                Log.i("zobbi","Error: Payload missing\nSelect a payload to send first" );

            }

        };

    }

    private void stopTimerTask()
    {
        if ( timer != null )
        {
            timer.cancel();
            timer = null;
        }

    }

}
