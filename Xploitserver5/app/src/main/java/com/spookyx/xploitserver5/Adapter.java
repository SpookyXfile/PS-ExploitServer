package com.spookyx.xploitserver5;

import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;


@SuppressWarnings("unused")
public class Adapter extends Selectable_Adapter<Adapter.ViewHolder>
{
    private final static int TYPE_INACTIVE  = 0;
    private final static int TYPE_ACTIVE    = 1;

    private static boolean _enableListView;

    private static ArrayList<Item>  items;
    private static int              selectItemPos;

    private ViewHolder.ClickListener clickListener;


    Adapter( ViewHolder.ClickListener clickListener, Context context )
    {
        super();

        selectItemPos = -1;

        _enableListView = true;

        this.clickListener = clickListener;

        // Create some items
        items = new ArrayList<>();

        Utils utils = new Utils();

        Log.i( "zobbi", "Adapter - storage dir : " + utils.getExploitStorageDir( context ) + "/exploitItemList.xml" );

        items = utils.openItemXml(utils.getExploitStorageDir( context ) + "/exploitItemList.xml", items );

    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder( @NonNull ViewGroup parent, int viewType )
    {
        final int layout = ( viewType == TYPE_INACTIVE ) ? R.layout.item : R.layout.item_active;

        View v = LayoutInflater.from( parent.getContext() ).inflate( layout, parent,false );

        return new ViewHolder( v, clickListener );
    }

    @Override
    public void onBindViewHolder( @NonNull ViewHolder holder, int position )
    {
        final Item item = items.get( position );

        holder.imageView.setImageResource( R.drawable.item_2 );

        holder.title.setText( item.getTitle() );
        holder.subtitle.setText( item.getSubtitle() );

    }

    @Override
    public int getItemViewType( int position )
    {
        final Item item = items.get( position );

        //return item.isActive() ? TYPE_ACTIVE : TYPE_INACTIVE;
        return isSelected( position ) ? TYPE_ACTIVE : TYPE_INACTIVE;

    }

    static int getSelectItemPos()
    {

        return selectItemPos;
    }

    void setEnableListView( boolean enable )
    {
        _enableListView = enable;
    }

    public static class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener, View.OnLongClickListener
    {
        ImageView   imageView;

        TextView    title;
        TextView    subtitle;

        private ClickListener listener;

        ViewHolder( View itemView, ClickListener listener )
        {
            super( itemView );

            imageView   = itemView.findViewById( R.id.image );
            title       = itemView.findViewById( R.id.title );
            subtitle    = itemView.findViewById( R.id.subtitle );

            this.listener = listener;

            itemView.setOnClickListener( this );
            itemView.setOnLongClickListener( this );
        }


        @Override
        public void onClick( View v )
        {
            if ( listener != null && _enableListView )
            {
                int posItem = getAdapterPosition();

                selectItemPos = posItem;

                listener.onItemClicked( posItem );
            }

        }

        // Todo Add onclick release ???? pour selectItemPos = -1 -> reset

        @Override
        public boolean onLongClick( View v )
        {
            if ( listener != null && _enableListView )
            {
                return listener.onItemLongClicked( getAdapterPosition() );
            }

            return false;
        }

        public interface ClickListener
        {
            void    onItemClicked( int position );
            boolean onItemLongClicked( int position );

        }

    }

    ArrayList<Item> getItemList()
    {

        return items;
    }

    static ArrayList<Item> getStaticItemList()
    {

        return items;
    }

    @Override
    public int getItemCount()
    {

        return items.size();
    }

    //void addItem( String title, String subtitle, boolean activeItem, String folder )
    void addItem( String title, String subtitle, String folder )
    {
        items.add( new Item( title, subtitle,false, folder ) );

        notifyItemInserted( items.size() );

    }

    private void removeItem( int position )
    {
        items.remove( position );

        notifyItemRemoved( position );

    }

    void removeItems( List<Integer> positions )
    {
        // Reverse-sort the list
        Collections.sort( positions, new Comparator<Integer>()
        {
            @Override
            public int compare( Integer lhs, Integer rhs )
            {
                return rhs - lhs;
            }

        } );

        // Split the list in ranges
        while ( !positions.isEmpty() )
        {
            if ( positions.size() == 1 )
            {
                removeItem( positions.get( 0 ) );
                positions.remove(0 );

            }
            else
            {
                int count = 1;

                boolean isEqualCount = positions.get( count ).equals( positions.get( count - 1 ) - 1 );

                while ( ( positions.size() > count ) &&  isEqualCount )
                {
                    ++count;
                }

                if ( count == 1 )
                {
                    removeItem( positions.get( 0 ) );
                }
                else
                {
                    removeRange( positions.get( count - 1 ), count );
                }

                    /*
                    for ( int i = 0; i < count; ++i )
                    {
                        positions.clear();remove(0);
                    }
                    */
                positions.clear();
            }
        }

    }

    private void removeRange (int positionStart, int itemCount )
    {
        for ( int i = 0; i < itemCount; ++i )
        {
            items.remove( positionStart );
        }

        notifyItemRangeRemoved( positionStart, itemCount );
    }

}
